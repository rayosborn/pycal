# PyCal - Python web calendar
#
# Copyright (C) 2004 Ray Osborn
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# $Id: HTML.py,v 1.5 2004/07/30 16:49:18 osborn Exp $
#
"""PyCal submodule containing HTML formatting modules and classes. 

These routines draw heavily on 'htmlformat.py' in the Mailman package.

Those HTML tags that can hold multiple HTML tags are made subclasses
of a general Container class, which will accept arbitrary keyword arguments,
has an Add method for adding other objects, and a __str__ method for 
generating the HTML output of everything added so far.

Other HTML tags are generated by modules that return the HTML string.
"""

from PyCal import *

# Miscellaneous variables
_LEVEL = 0
_INDENT = '  '
_NEWLINE = '\n'
TAB = '&nbsp;&nbsp;&nbsp;&nbsp;' # This one is exported

class Container(object):

    """Base class for HTML objects containing multiple items.
    
    __init__ has one optional argument:
    
    tag - The HTML tag of the object
    
    Additional arguments are treated as separate items that are added to the
    list of contained objects.  Items can also be appended to this list
    using the Add method.  If an argument is a list object, it is expanded
    before being appended.  These contained objects are output using their
    own string methods
    
    Keyword arguments will be interpreted as tag attributes, with the values
    output as strings.  In this way, arbitrary attributes can be added to 
    the HTML tag.  However, the "class" attribute has to use the keyword
    "class_", since "class" is reserved by Python.
    
    The tag and its contents are output as HTML 4.0 standard-conforming
    code.  Empty tags are output according to the XHTML prescription.
    """
    
    def __init__(self, tag=None, *items, **opts):
        self.tag = tag
        self.items = []
        for item in items:
            if isinstance(item, list) or isinstance(item, tuple):
                for eachItem in item:
                    self.items.append(eachItem)
            else:
                self.items.append(item)
        self.opts = opts
    
    def __str__(self):
        global _LEVEL
        output = []
        if self.tag:
            text = _LEVEL*_INDENT + '<%s' % self.tag
            for item in self.opts.keys():
                value = str(self.opts[item])
                if item == "class_":
                    attribute = "class"
                else:
                    attribute = item 
                text = '%s %s="%s"' % (text, attribute, value)
            if not self.items:
                return text+' />'
            text = text + '>'
            output.append(text)
            _LEVEL = _LEVEL + 1
        for item in self.items:
            if isinstance(item, str):
                for line in item.splitlines():
                    output.append(_LEVEL*_INDENT+line.rstrip())
            else:
                output.append(_LEVEL*_INDENT+str(item).strip())
        if self.tag:
            _LEVEL = _LEVEL - 1
            output.append(_LEVEL*_INDENT+'</%s>' % self.tag)
        return _NEWLINE.join(output)

    def Add(self, item):
        if item: 
            self.items.append(item)


class InlineContainer(Container):

    """Container class for inline tags."""
    
    def __str__(self):
        output = []
        if self.tag:
            text = '<%s' % self.tag
            for item in self.opts.keys():
                value = str(self.opts[item])
                if item == "class_":
                    attribute = "class"
                else:
                    attribute = item
                text = '%s %s="%s"' % (text, attribute, value)
            if not self.items:
                return text+' />'
            text = text + '>'
            output.append(text)
        if self.items:
            output.append(' '.join(map(str, self.items)))
        if self.tag:
            output.append('</%s>' % self.tag)
        return ''.join(output)


class HTML(Container):

    """Container class for the HTML tag.
    
    A document type is prepended to the string output.
    """
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'html', *items, **opts)
        if "xmlns" not in self.opts.keys():
            self.opts["xmlns"] = "http://www.w3.org/1999/xhtml"
    
    def __str__(self):
        return "%s%s" % (DocType(), Container.__str__(self))


class Head(Container):

    """Container class for the HTML head block."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'head', *items, **opts)


class Title(InlineContainer):

    """Container class for the HTML head title."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'title', *items, **opts)


class Link(Container):

    """Container class for the HTML head link block."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'link', *items, **opts)


class StyleLink(Link):

    """Container class for a stylesheet link."""

    def __init__(self, *items, **opts):
        Link.__init__(self, *items, **opts)
        if "rel" not in self.opts.keys():
            self.opts["rel"] = "stylesheet"
        if "type" not in self.opts.keys():
            self.opts["type"] = "text/css"
        if "href" not in self.opts.keys():
            if self.items:
                self.opts["href"] = "%s/%s" % (webURL, self.items[0])
                self.items.pop(0)
            

class Style(Container):

    """Container class for a style tag."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'style', *items, **opts)
        if "type" not in self.opts.keys():
            self.opts["type"] = "text/css"


class Script(Container):

    """Container class for script tag.
    
    Comment markers are inserted just after the opening tag and before
    the closing tag for browsers that don't recognize javascript.
    """
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'script', *items, **opts)
        if "language" not in self.opts.keys():
            self.opts["language"] = "Javascript"
        self.items.insert(0, '<!--')

    def __str__(self):
        self.items.append('//-->')
        return Container.__str__(self)


class Base(Container):

    """Container class for a base tag."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'base', *items, **opts)
        if "target" not in self.opts.keys():
            self.opts["target"] = "_TOP"


class Meta(Container):

    """Container class for a meta tag."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'meta', *items, **opts)


class ContentType(Meta):

    """Container class for a content-type meta tag."""

    def __init__(self, *items, **opts):
        Meta.__init__(self, *items, **opts)
        self.opts["http-equiv"] = "Content-Type" 
        if "content" not in self.opts.keys():
            self.opts["content"] = "text/html; charset=UTF-8"


class Body(Container):

    """Container class for the HTML body."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'body', *items, **opts)


class Div(Container):

    """Container class for a block division."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'div', *items, **opts)


class Span(InlineContainer):

    """Container class for an inline span."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'span', *items, **opts)


class Para(Container):

    """Container class for a paragraph."""
    
    def __init__(self, *items, **opts):
        Container.__init__(self, 'p', *items, **opts)


class Header(Container):

    """Container class for a header of the specified level."""
    
    def __init__(self, *items, **opts):
        if "level" in opts.keys():
            level = opts["level"]
            del opts["level"]
        else:
            level = 1
        Container.__init__(self, 'h%s' % level, *items, **opts)


class UnorderedList(Container):

    """Container class for an unordered list.
    
    The Add method appends items as ListItem objects.
    """
        
    def __init__(self, *items, **opts):
        Container.__init__(self, 'ul', *items, **opts)
        list = []
        for item in self.items:
            list.append(ListItem(item))
        self.items = list

    def Add(self, item):
        if item:
            self.items.append(ListItem(item))


class OrderedList(Container):

    """Container class for an ordered list.
    
    The Add method appends items as ListItem objects.
    """

    def __init__(self, *items, **opts):
        Container.__init__(self, 'ol', *items, **opts)
        list = []
        for item in self.items:
            list.append(ListItem(item))
        self.items = list

    def Add(self, item):
        if item:
            self.items.append(ListItem(item))


class ListItem(Container):

    """Container class for a list item."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'li', *items, **opts)


class DefinitionList(Container):

    """Container class for a definition list.
    
    If the argument list contains any dictionaries, the keys are treated
    as DefinitionTerms and the values as DefinitionItems.
    """

    def __init__(self, *items, **opts):
        Container.__init__(self, 'dl', *items, **opts)
        list = []
        for item in self.items:
            if isinstance(item, dict):
                for term in item:
                    list.append(DefinitionTerm(term))
                    list.append(DefinitionItem(item[term]))
            else:
                list.append(item)
        self.items = list

    def Add(self, item):
        if item:
            if isinstance(item, dict):
                for term in item:
                    self.items.append(DefinitionTerm(term))
                    self.items.append(DefinitionItem(item[term]))
            else:
                self.items.append(item)


class DefinitionTerm(Container):

    """Container class for a definition term."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'dt', *items, **opts)


class DefinitionItem(Container):

    """Container class for a definition list item."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'dd', *items, **opts)


class Table(Container):

    """Container class for a table."""
        
    def __init__(self, cols=[], *items, **opts):
        Container.__init__(self, 'table', *items, **opts)
        if "width" not in self.opts.keys():
            width = 0
            for col in cols:
                width += col
            if width > 0: 
                self.opts["width"] = width
        if "align" not in self.opts.keys():
            self.opts["align"] = "center"
        if "cellspacing" not in self.opts.keys():
            self.opts["cellspacing"] = 0
        if cols:
            self.items.insert(0, Colgroup(cols))


class Colgroup(Container):

    """Container class for a colgroup."""
    def __init__(self, cols=[], *items, **opts):
        Container.__init__(self, 'colgroup', *items, **opts)
        for width in cols:
            self.items.append(Column(width=width))


class Column(Container):

    """Container class for a table column."""
    def __init__(self, *items, **opts):
        Container.__init__(self, 'col', *items, **opts)


class Row(Container):

    """Container class for a table row."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, 'tr', *items, **opts)


class Cell(Container):

    """Container class for a table cell."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, 'td', *items, **opts)
        for index in range(len(self.items)):
            if str(self.items[index]).strip() == "":
                self.items[index] = "&nbsp;"
 
 
class HeaderCell(Cell):

    """Container class for a table header."""
        
    def __init__(self, *items, **opts):
        Cell.__init__(self, *items, **opts)
        self.tag = "th"


class HorizontalRule(Container):

    """Container class for a horizontal rule."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'hr', *items, **opts)


class Break(InlineContainer):

    """Container class for a line break."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'br', *items, **opts)
        

class Image(InlineContainer):

    """Inline Container class for images.
    
    The first argument is the source of the image file.
    """

    def __init__(self, src, *items, **opts):
        Container.__init__(self, 'img', *items, **opts)
        if src <> "":
            self.opts["src"] = src


class Anchor(InlineContainer):

    """Inline Container class for anchors.
    
    The first argument is the URL of the anchor.
    """

    def __init__(self, url, *items, **opts):
        Container.__init__(self, 'a', *items, **opts)
        if url <> "":
            self.opts["href"] = url
        else:
            self.opts["href"] = ""

    def __str__(self):
        if not self.items:
            self.items = [self.opts["href"]]
        if "scheme" in self.opts.keys():
            if not self.opts["scheme"].endswith(":"):
                self.opts["scheme"] = "%s:" % self.opts["scheme"]
            self.opts["href"] = "%s%s" % (self.opts["scheme"], 
                                           self.opts["href"])
            del self.opts["scheme"]
        return str(InlineContainer("a", *self.items, **self.opts))
        

class NamedAnchor(InlineContainer):

    """Inline Container class for named anchors.
    
    The first argument is the name of the anchor. 
    If there are no other arguments, a space is added
    so that the tag will not be completely empty.
    """

    def __init__(self, name, *items, **opts):
        Container.__init__(self, 'a', *items, **opts)
        if name <> "":
            self.opts["name"] = name
        if not self.items:
            self.items = [" "]


class Strong(InlineContainer):

    """Inline Container class for strongly emphasized text."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'strong', *items, **opts)


class Emphasis(InlineContainer):

    """Inline Container class for emphasized text."""

    def __init__(self, *items, **opts):
        Container.__init__(self, 'em', *items, **opts)


class Form(Container):

    """Container class for a CGI form.
    
    The first argument is the name of the CGI script.
    The keyword "location" refers to the URL prefix for CGI scripts.
    """
        
    def __init__(self, script, *items, **opts):
        if opts.has_key("location"):
            formURL = opts["location"]
            del opts["location"]
        else:
            formURL = cgiURL
        if script <> "":
            opts["action"] = '%s/%s' % (formURL, script)
            opts["method"] = 'post'
            opts["enctype"] = 'multipart/form-data'
        Container.__init__(self, 'form', *items, **opts)


class Input(InlineContainer):

    """Container class for form input."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, 'input', *items, **opts)
        if "type" not in self.opts.keys():
            self.opts["type"] = "text"
        if "name" not in self.opts.keys() and self.items:
            self.opts["name"] = self.items[0]
            self.items.pop(0)
        if "value" not in self.opts.keys() and self.items:
            self.opts["value"] = self.items[0]
            self.items.pop(0)
        if "checked" in self.opts.keys():
            self.opts["checked"] = "checked"
        if "readonly" in self.opts.keys():
            self.opts["readonly"] = "readonly"


class Submit(Input):

    """Container class for a submit button."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "submit"
        Input.__init__(self, *items, **opts)
        if "name" in self.opts.keys() and \
           "value" not in self.opts.keys():
            self.opts["value"] = self.opts["name"]


class Radio(Input):

    """Container class for a radio button."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "radio"
        Input.__init__(self, *items, **opts)


class Checkbox(Input):

    """Container class for a checkbox."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "checkbox"
        Input.__init__(self, *items, **opts)


class FileInput(Input):

    """Container class for hidden variables."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "file"
        Input.__init__(self, *items, **opts)


class HiddenInput(Input):

    """Container class for hidden variables."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "hidden"
        Input.__init__(self, *items, **opts)


class Password(Input):

    """Container class for password inputs."""
        
    def __init__(self, *items, **opts):
        opts["type"] = "password"
        Input.__init__(self, *items, **opts)


class Select(InlineContainer):

    """Container class for a selection group."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, "select", *items, **opts)


class MultipleSelect(Select):

    """Container class for a multiple selection group."""
        
    def __init__(self, *items, **opts):
        Select.__init__(self, *items, **opts)
        self.opts["multiple"] = "multiple"


class Option(InlineContainer):

    """Container class for an option."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, "option", *items, **opts)


class SelectedOption(Option):

    """Container class for a selected option."""
        
    def __init__(self, *items, **opts):
        Option.__init__(self, *items, **opts)
        self.opts["selected"] = "selected"


class TextArea(InlineContainer):

    """Container class for a text area."""
        
    def __init__(self, *items, **opts):
        Container.__init__(self, 'textarea', *items, **opts)
        if "name" not in self.opts.keys() and self.items:
            self.opts["name"] = self.items[0]
            self.items.pop(0)
        if "rows" not in self.opts.keys():
            self.opts["rows"] = 10
        if "cols" not in self.opts.keys():
            self.opts["cols"] = 60

    def __str__(self):
        if not self.items:
            self.items = " "
        return str(InlineContainer("textarea", *self.items, **self.opts))
            

class Comment(InlineContainer):
    """Container class for comments."""
    
    def __init__(self, *items, **opts):
        self.items = []
        for item in items:
            if isinstance(item, list) or isinstance(item, tuple):
                for eachItem in item:
                    self.items.append(eachItem)
            else:
                self.items.append(item)
        self.opts = opts

    def __str__(self):
        output = ['<!--']
        if self.items:
            output.append(' '.join(map(str, self.items)))
        output.append('-->')
        return ' '.join(output)


def Page(title=None, content=None, top=None, bottom=None, stylesheet=None):
    """Return standard page."""
    output = HTML()
    h = Head()
    h.Add(ContentType())
    if title:
        h.Add(Title(title))
    if stylesheet:
        h.Add(StyleLink(stylesheet))
    else:
        h.Add(StyleLink("pycal.css"))
    output.Add(h)
    b = Body()
    frame = Div(id="frame")
    if top:
        frame.Add(top)
    else:
        frame.Add(Top())
    if content:
        frame.Add(content)
    if bottom:
        frame.Add(bottom)
    else:
        frame.Add(Bottom())
    b.Add(frame)
    output.Add(b)
    return output

def Top():
    """Output HTML for the top of the standard page."""
    output = Div()
    output.Add(Anchor("http://www.dgfumc.org/", 
                      Image("/images/banner.gif", width="725", height="103",
                      border="0", 
                      alt="First United Methodist Church, Downers Grove")))
    return output

def Bottom():
    """Output HTML for the top of the standard page."""
    output = Container()
    p = Para(class_="footer", style="text-align:center")
    p.Add(Span("First United Methodist Church",           
                style="font-size:1.1em; font-weight:bold"))
    p.Add(Break())
    p.Add("%s%s" %
          ("First United Methodist Church, 1032 Maple Avenue, Downers Grove,",
          "IL 60515 - Phone (630) 968-7120 - Fax (630) 968-4901"))
    p.Add(Break())
    p.Add("E-mail: %s" % Anchor("dgfumc@dgfumc.org", scheme="mailto"))
    output.Add(p)
    p = Para(style="font-size:0.75em; margin-top:0")
    p.Add("%s%s%s." %
          ("Copyright &copy; 2004-2008 First United Methodist Church,",
           "Downers Grove. Please report any problems to ",
           Anchor("webmaster@dgfumc.org", scheme="mailto")))
    output.Add(p)
    return output

def FramePage(title=None, content=None, width=None):
    """Return standard page."""
    output = HTML()
    h = Head()
    h.Add(ContentType())
    if title:
        h.Add(Title(title))
    h.Add(StyleLink("pycal.css"))
    if width:
        h.Add(Style("body {width:%spx}" % width))
    h.Add(Base(target="_top"))
    output.Add(h)
    b = Body()
    if content:
        b.Add(content)
    output.Add(b)
    return output

def Selections(name, choices=[], selected=None, multiple=False, label=False, 
               size=8):
    """Return HTML selection menu.
    
    The first argument is the name of the selected variable.
    The second argument is a list of available options.
    The third argument is a list of selected options.
    """
    if multiple:
        output = MultipleSelect(name="%s" % name, size="%s" % size)
    else:
        output = Select(name="%s" % name)    
    if label:        
        output.Add(Option("%s..." % name.capitalize()))
    for choice in choices:
        chosen = False
        if selected:
            if isinstance(selected, list):
                if choice in selected:
                    chosen = True
            elif choice == selected:
                chosen = True
        if chosen:
            output.Add(SelectedOption(choice))        
        else:
            output.Add(Option(choice))
    return output

def RadioButtons(name, options, checked=None, descriptions=[]):
    """Return a list of radio buttons."""
    output = Span()
    index = 0
    for option in options:
        if option == checked:
            output.Add(Radio(name, option, checked=1))
        else:
            output.Add(Radio(name, option))
        if descriptions:
            output.Add("%s%s" % (descriptions[index], TAB))
        else:
            output.Add("%s%s" % (options[index].capitalize(), TAB))
        index = index + 1
    return output

def Checkboxes(name, options, checked=[], descriptions=[], columns=None):
    """Return a list of checkboxes."""
    output = Span()
    if not columns:
        columns = 999
    column = 1
    index = 0
    for option in options:
        if option in checked:
            output.Add(Checkbox(name, option, checked=1))
        else:
            output.Add(Checkbox(name, option))
        if descriptions:
            output.Add("%s%s" % (descriptions[index], TAB))
        else:
            output.Add("%s%s" % (options[index].capitalize(), TAB))
        index = index + 1
        column = column + 1
        if column > columns:
            output.Add(Break())
            column = 1
    return output

def DocType():
    """Return string containing DOCTYPE specifier."""
    return """<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">\n"""
